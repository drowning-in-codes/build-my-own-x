仿函数的功能很强大。他们由一个独立的类所表示，您可以根据您的需要来设计、改造并使用它。

然而 C++98/03 问题在于需要在不同的地方编写一个函数或者仿函数，而不是算法调用对象本身。

这意味着这段代码会在源文件的中占用几十到上百行，而且这样分离的写法并不利于日后代码的维护。

一个可行的解决办法，那就是再编写一个本地仿函数类，因为 C++ 支持这样的语法，但是这不意味着它能如预期一样工作
在 C++98/03 中，你不能用本地类型(局部变量)来初始化一个模板
但是c++98/03中，你不能用本地类型来初始化一个模板。这意味着你不能在函数内部定义一个仿函数类，然后将其传递给一个算法。
可以使用辅助函数。
在 C++98/03 中，有很多方式来声明或者传递一个可调用对象给标准库的算法或者公用组件。

然而，所有的这些都一些限制。例如，你不能声明一个本地的仿函数对象，以及使用辅助函数组合起来的一个复杂表达。

幸运的是，在 C++11 中我们有了很多新的提升。

首先，C++ 委员会解除了使用本地类型的模板进行实例化的限制。

现在你可以在你需要的地方编写本地仿函数了。

还有，C++带来了另一个想法：如果编译器可以为开发人员“编写”小巧简洁的仿函数呢？

这意味着通过一些新语法，我们可以“就地”创建仿函数。

C++ 从此开启了更简洁、更紧凑的语法的新篇章。

这就是 Lambda 表达式的诞生。
